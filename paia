#!/usr/bin/env python
from imports import *

def run():
    args = sys.argv
    print args
    if(len(args) > 1):
        '''
        print "Input args: ", sys.argv
        print "Main bod: ", bod
        '''
        timed = 0
        if "timed" in args:
            print "Timing!"
            start = ptime.now()
            timed = 1
            args.remove("timed")
        bod = pdata.getLocal("Config")
        orgArgs = readArgs(args, bod)
        db = pdata.getLocal("DB")
        newRead(bod)
        if timed:
            ptime.length(start)
    else:
        print "No commands found. What would you like?"

def readArgs(argv, bod):
    '''
    print "Attemping to read: ", argv
    print "Reading Bod: ", bod
    '''
    bod["inputArgs"] = {}
    modules = bod["modules"]
    functions = bod["functions"]
    current = "Random"
    timed = 0
    
    for c in range(1,len(argv)):
        temp = argv[c]
        for function in functions:
            if temp == function.split(".")[1]:
                if temp not in bod['inputArgs']:
                    bod['inputArgs'][function] = []
                    current = function
                    break
            elif current in bod['inputArgs'].keys() and temp != current.split(".")[1]:
                bod['inputArgs'][current].append(temp)
                break
        #print current
    return bod

def newRead(bod):
    print "newRead: ", bod["inputArgs"]
    for key,val in bod["inputArgs"].items():
        print "Key: ", key, "; Val: ", val
        myClass = __import__(key.split(".")[0])
        myFunc = key.split(".")[1]
        #print "myClass: ", myClass, "\nmyFunc: ", myFunc
        '''
        Separate the method call and use it in a toolbox. Can be used in here and db
        '''
        method = None
        try:
            method = getattr(myClass, myFunc)
            method(val)
            #break;time this
        except AttributeError:
            print ("Unable to call selected function with inputArgs:")
        
if __name__ == '__main__':
    run()
